# Exceptions and Interrupts

Exceptions are unusual conditions that occur at run time, associated with an 
instruction in the current RISC-V hart.

Interrupts are events that occur asynchronously outside any of the RISC-V harts.

The mechanism to process exceptions and interrupts is one of the main 
improvements in the RISC-V microcontroller profile versus the privileged
profile.

## Exceptions

Exceptions trigger a **synchronous transfer of control** to an exception handler 
within the current hart.

Some exceptions cannot be disabled, and handlers to process them should always be installed.

Some exceptions are **resumable**, i.e. execution can continue to the next 
instruction (for example the illegal instruction handler can implement a custom 
instruction and resume).

Exceptions, in decreasing priority order:

* Instruction address misaligned 
* Instruction access fault
* Illegal instruction
* Breakpoint
* Load address misaligned
* Load access fault
* Store/AMO address misaligned 
* Store/AMO access fault 
* Environment call from U-mode
* Environment call from M-mode
* Instruction page fault
* Load page fault
* Store/AMO page fault

TODO: rework for microcontrollers

TODO: NMI? routed only to hart 0?

### Exceptions vector table

The exceptions vector table is an array of addresses (xlen size elements) pointing to 
interrupt handlers (C/C++ functions).

The address of the exceptions vector table is kept by each hart in (`hcb.excvta`); 
it is automatically initialised at startup with 
the address provided in the hart startup block and can be later writen by software.

## Interrupts

Interrupts are generaly **triggered by peripherals** to notify the application of a 
given condition or event. 

Interrupts trigger the transfer of control to an interrupt handler associated with 
a hart.

A hart can have up to **1024** interrupts, including the system interrupts.

### Interrupt priorities

Interrupts have **programable priorities**, defined as small unsigned numbers, 
usually bytes.
The **priority value 0** is reserved to mean 
_'never interrupt'_ or _'disabled'_, and interrupt priorities increase with 
an increasing integer value.

Interrupts with the same priority are processed in the order of their index 
in the interrupt 
table, with a higher index meaning a higher priority.

For multi-hart devices, the interrupt wiring to harts is implementation specific; 
each interrupt 
may be wired to one or several harts; it is the responsibility 
of each hart to enable the interrupts it desires to process. For redundant systems, 
it is also
possible for multiple harts to process the same interrupt.

### Interrupt priority threshold

Each hart has an associated priority threshold, held in a hart-specific register. 

Only interrupts that have a priority strictly greater than the threshold will 
cause an interrupt to 
be sent to the hart.

### Priority bits

The actual number of bits used to store the interrupt priority is implementation 
specific, but must 
be at least 3 (i.e. at least 8 priority levels).

> <sup>Extra care must be considered when moving code to implmentations with fewer 
  priority levels, since truncation could lead to priority inversions.
  For example, when moving a program from devices 
  with 4-bit priority bits to devices with 3-bit priorities, if the application 
  uses priority 9 for IRQ0 and priority 3 
  for IRQ1, IRQ0 is expected to have a higher 
  priority. But if the MSB bit is removed, IRQ0 will have priority 1 and be 
  lower than IRQ1.</sup>
  
> <sup>It is 
  recommended that software handling priorities know about the numbr of bits 
  and use asserts to validate the priority values.</sup>

### Interrupt preemption and nesting

If an hart is executing an interrupt handler and a higher priority interrupt 
occurs, the current interrupt handler is temporarily suspended and the higher 
priority interrupt handler is executed to completion, than the first 
interrupt handler is resumed.

Each new interrupt creates a new context on the main stack, and removes it 
when the handler returns.

There is no limit for interrupt nesting, assuming the main stack is large enough.

### System interrupts

System interrupts are generated by system peripherals, like `sysclock`, `rtclock`.

TBD

### Interrupts vector table

The interrupts table is an **array of pointers** to interrupt handlers, 
implemented as **C/C++ functions**. The number of interrupts per hart is 
implementation specific but cannot exceed 1024 elements.

Each hart has its own table, with handlers for the interrupts it can process.

The address of the array must be programatically written by each hart to 
its `hcb.intvta` register before enabling interrupts, usually during startup.

The first 8 entries are reserved for system interrupts:

* `context_switch` (must have the lowest priority)
* `rtclock_cmp`
* `sysclock_cmp`

## Vector tables relocation

The starting address used by a RISC-V microcontroller be boot memory is usually 
either a flash memory or a ROM device, and the value cannot be changed at run-time. 
However, some applications, like booladers or applications running in RAM, 
start with the vector tables at one 
address and later transfer control to the application located at a different 
address. For such cases it is useful to be able to modify or define vector tables 
at run-time. In order to handle this, the RISC-V microcontroller support a feature 
called Vector Table Relocation.

For this, the `hcb.excvta` and `hcb.intvta` registers can be written at any time from 
code running in machine mode.

## Context stack

When exceptions and interrupts are taken, they push a context on the main stack. 
The stack pointer must be xlen aligned. For RV32 harts with the D extension, 
an additional alignment to 8 must be performed by adding a stack padding.

If the `stackalign` bit in the `ctrl` CSR is set, the stack is always aligned
at 8. Depending on how caches are organised, it usually allow faster context
switches.

For the current RISC-V Linux ABI, the stack context is, from hight to low addresses

- <- original sp 
- optional padding
- fcsr (\*) <- for double, it must be aligned to 8
- ft11 (\*)
- ft10 (\*)
- ft9 (\*)
- ft8 (\*)
- fa7 (\*)
- fa6 (\*)
- fa5 (\*)
- fa4 (\*)
- fa3 (\*)
- fa2 (\*)
- fa1 (\*)
- fa0 (\*)
- ft7 (\*)
- ft6 (\*)
- ft5 (\*)
- ft4 (\*)
- ft3 (\*)
- ft2 (\*)
- ft1 (\*)
- ft0 (\*)
- status (CSR, the current mode when the exception/interrupt occured)
- pc (the next address to return from the exception/interrupt)
- t6
- t5
- t4
- t3
- a7
- a6
- a5
- a4
- a3
- a2
- a1
- a0
- t2
- t1
- t0
- ra <- new sp

The floating point registers are not saved by devices that do not implement the 
F or D extentions and do not have the `ctrl.fpena` bit set.

To reduce latency, in parallel with saving the registers, the address of the exception/interrupt
handler is fetched from the vector table.

After saving the context stack:

- the `handler` bit in the `status` is set, to mark the handler-mode
- the `ra` register is adjusted to a special pattern 
that is illegal as a return address
- the `pc` register is loaded with the handler address; this is 

The special pattern is an 'all-1' for the given xlen.

When the C/C++ function returns, it'll load `pc` with the specail return address in `ra`. 
This will trigger the exception return mechanism, which will pop the context from the stack 
and return from the interrupt/exception.











