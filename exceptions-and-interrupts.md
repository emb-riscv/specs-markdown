# Exceptions and Interrupts

Exceptions are unusual conditions occuring at run time, associated with an instruction in the current RISC-V hart.

Interrupts are events that occur asynchronously outside any of the RISC-V harts.

## Exceptions

Exceptions trigger **a synchronous transfer of contro**l to an exception handler within the current hart.

Exceptions cannot be disabled, and handlers to process them should always be installed.

Some exceptions are **resumable**, i.e. execution can continue to the next instruction (for example the illegal instruction handler can implement a custom instruction and resume).

Exceptions, in decreasing priority order:

* Instruction address misaligned 
* Instruction access fault
* Illegal instruction
* Breakpoint
* Load address misaligned
* Load access fault
* Store/AMO address misaligned 
* Store/AMO access fault 
* Environment call from U-mode
* Environment call from M-mode
* Instruction page fault
* Load page fault
* Store/AMO page fault

TODO: rework for microcontrollers
TODO: NMI? routed only to hart 0?

## Interrupts

Interrupts are generaly **triggered by peripherals** to notify the application of a given condition or event. 

Interrupts trigger the transfer of control to an interrupt handler associated with a hart.

A hart can have up to **1024** interrupts, including the system interrupts.

### Interrupt priorities

Interrupts have **programable priorities**, defined as small unsigned numbers, usually bytes.
The **priority value 0** is reserved to mean 
_'never interrupt'_ or _'disabled'_, and interrupt priorities increase with an increasing integer value.

Interrupts with the same priority are processed in the order of their index in the interrupt 
table, with a higher index meaning a higher priority.

For multi-hart devices, the interrupt wiring to harts is implementation specific; each interrupt 
may be wired to one or several harts; it is the responsibility 
of each hart to enable the interrupts it desires to process. For redundant systems, it is also
possible for multiple harts to process the same interrupt.

### Interrupt priority threshold

Each hart has an associated priority threshold, held in a hart-specific register. 

Only interrupts that have a priority strictly greater than the threshold will cause an interrupt to 
be sent to the hart.

The threashold register should always be able to hold the value of zero, in which case no interrupts are 
masked. The threshold register should always be able to hold the 'all-1' value, in which case all interrupts 
are masked (functionally equivalent to disabling interrupts).

### Priority bits

The actual number of bits used to store the interrupt priority is implementation specific, but should be in the range [3-8].

If lower than 8 bits are implemented, the existing bits should always store the most significant bits (MSB), 
with the least significant bits (LSB) ignored on write and reading 0.

> <sup>The reason for removing the LSB instead of MSB is to make it easier to port software between RISC-V devices
with different priority bits schemes. In this way, a program written for devices with 4-bit priority bits is likely to 
be able to run on devices with 3-bit priority bits. If the MSB 
is removed instead of the LSB, it might be possible to get a priority inversion,  
for example, if an application uses priority level 0x05 for IRQ0 and level 0x03 for IRQ1, IRQ0 should have higher 
priority. But when MSB bit 2 is removed, IRQ0 will become level 0x01 and have a lower priority than IRQ1.</sup>

### System interrupts

System interrupts are generated by system peripherals, like `sysclock`, `rtclock`.

TBD

### Interrupts table

The interrupts table is an **array of pointers** to interrupt handlers, implemented as **C/C++ functions**. The number of interrupts per hart is implementation specific but cannot exceed 1024 elements.

Each hart has its own table, with handlers for the interrupts it can process.

The address of the array must be programatically written by each hart to its `hic.irqtab` register before enabling interrupts, usually during startup.

The first 8 entries are reserved for system interrupts:

* `context_switch` (must have the lowest priority)
* `rtclock_cmp`
* `sysclock_cmp`





