# Exceptions and Interrupts

Exceptions are generally unusual conditions occuring at run time, associated with an instruction in the current RISC-V hart.

Interrupts are external events that occur asynchronously outside any of the RISC-V harts.

## Exceptions

Exceptions trigger a synchronous transfer of control to an exception handler within the current hart.

Exceptions cannot be disabled, and handlers to process them should always be installed.

Some exceptions are resumable, i.e. execution can continue to the next instruction (for example the illegal instruction handler can implement a custom instruction and resume).

Exceptions, in decreasing priority order:

* Instruction address misaligned 
* Instruction access fault
* Illegal instruction
* Breakpoint
* Load address misaligned
* Load access fault
* Store/AMO address misaligned 
* Store/AMO access fault 
* Environment call from U-mode
* Environment call from M-mode
* Instruction page fault
* Load page fault
* Store/AMO page fault

TODO: rework for microcontrollers
TODO: NMI? routed only to hart 0?

## Interrupts

Interrupts are generaly triggered by peripherals to notify the application of a given condition or event. 

Interrupts trigger the transfer of control to an interrupt handler associated with a hart.

### Interrupt priorities

Interrupts have programable priorities, small unsigned numbers, usually bytes.
The priority value 0 is reserved to mean 
'never interrupt' or 'disabled', and interrupt priority increases with increasing integer value.

For multi-hart devices, all interrupts are wired to all harts, and it is the responsibility 
of each hart to enable the relevant priorities. For redundant systems, it is also
possible for multiple harts to process the same interrupt.

Each hart has an associated priority threshold, held in a hart-specific memory mapped register. The 
threashold register should always be able to hold the value of zero, in which case no interrupts are 
masked. The threshold register should be able to hold the 'all-1' value, in wich case all interrupts 
are masked (functionally equivalent to disabling interrupts).

Only interrupts that have a priority strictly greater than the threshold will cause an interrupt to 
be sent to the hart.

Interrupts with the same priority are processed in the order of their index in the interrupt 
table, with a higher index meaning a higher priority.

### Priority bits

The actual number of bits used to store the interrupt priority is device specific, but should be in the range [3-8].

If lower than 8 bits are implemented, the existing bits should always store the most significant bits (MSB), 
with the least significant bits (LSB) ignored on write and reading 0.

<sup>The reason for removing the LSB instead of MSB is to make it easier to port software between RISC-V devices
with different priority bits. In this way, a program written for devices with 4-bit priority bits is likely to 
be able to run on devices with 3-bit priority bits. If the MSB 
is removed instead of the LSB, it might be possible to get a priority inversion,  
for example, if an application uses priority level 0x05 for IRQ0 and level 0x03 for IRQ1, IRQ0 should have higher 
priority. But when MSB bit 2 is removed, IRQ0 will become level 0x01 and have a lower priority than IRQ1.</sup>

### System interrupts

System interrupts are generated by system peripherals, like `sysclock`, `rtclock`.

TBD

### Interrupt table

The interrupt table is an array of pointers to interrupt handlers, implemented as C/C++ functions.

Each hart has its own table, with handlers for the interrupts it is processing.

The address of the array must be written by each hart to its `hcb.irqtab` register before enabling interrupts, usually during startup.

The first 8 entries are reserved for system interrupts:

* `sysclock_tick`
* `rtclock_tick`
* `rtclock_wakeup`
* `context_switch`

TODO: define the order, which gives the priorities.

### Interrupt control registers

Each interrupt has some status attributes:

* Each interrupt can either be disabled (default) or enabled with a given priority
* Each interrupt can either be pending (a request is waiting to be served) or not
pending
* Each interrupt can either be in an active (being served) or inactive state.

To store and control these attributes, each interrupt has a 32-bits register with the following fields:


| Bits | Name | Type | Description |
|:-----|:-----|:-----|-------------|
| [7-0] | `prio` | rw | If non zero, the interrupt priority; if 0, the interrupt is disabled. |
| [8] | `pending` | r | Pending status bit; 1 if the interupt is pending. |
| [9] | `active` | r | Active status bit; 1 if the interupt is active. | |
| [15-10] ||| Reserved |
| [16] | `set_pend` | 1s | When 1 is written, set the pending bit. |
| [23-17] ||| Reserved |
| [24] | `clear_pend` | 1c | When 1 is written, clear the pending bit. |
| [31-25] ||| Reserved |


### Usage

Individual interrupts are enabled by writing a non-zero value to the `prio` field and are disabled by writing zero.

```c
hcb.interrupts[7].prio = 0xC0; // A byte write cycle.
hcb.interrupts[7].prio = 0;
```

Interrupts can be programatically set to pending by writing 1 in the `set_pend` field; the pending status can be cleared by writing 1 to the `clear_pend` field.

```c
hcb.interrupts[7].set = INTERRUPTS_SET_PENDING; // A byte write cycle.
hcb.interrupts[7].clear = INTERRUPTS_CLEAR_PENDING; // A byte write cycle.
```

To check the status bits:

```c
if (hcb.interrupts[7].status & INTERRUPTS_STATUS_PENDING) { // A byte read cycle.
  // ...
}
```


