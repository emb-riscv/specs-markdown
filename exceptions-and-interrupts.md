# Exceptions and Interrupts

Exceptions are unusual conditions occuring at run time, associated with an instruction in the current RISC-V hart.

Interrupts refer to external events that occur asynchronously to the RISC-V harts.

## Exceptions

Exceptions trigger a synchronous transfer of control to an exception handler in the current hart.

Exceptions, in decreasing priority order:

* Instruction address misaligned 
* Instruction access fault
* Illegal instruction
* Breakpoint
* Load address misaligned
* Load access fault
* Store/AMO address misaligned 
* Store/AMO access fault 
* Environment call from U-mode
* Environment call from M-mode
* Instruction page fault
* Load page fault
* Store/AMO page fault

TODO: rework for microcontrollers
TODO: NMI? routed only to hart 0?

## Interrupts

Interrupts are generaly triggered by peripherals to notify the application of a given condition or event. 
Interrupts trigger the transfer of control to an interrupt handler associated with a hart.

### Interrupt priorities

Interrupts have programable priorities, small unsigned numbers, usually bytes.
The priority value 0 is reserved to mean 
'never interrupt' or 'disabled', and interrupt priority increases with increasing integer value.

For multi-hart devices, all interrupts are wired to all harts, and it is the responsibility 
of each hart to enable the relevant priorities. For redundant systems, it is also
possible for multiple harts to process the same interrupt.

Each hart has an associated priority threshold, held in a hart-specific memory mapped register. The 
threashold register should always be able to hold the value of zero, in which case no interrupts are 
masked. The threshold register should be able to hold the 'all-1' value, in wich case all interrupts 
are masked (functionally equivalent to disabling interrupts).

Only interrupts that have a priority strictly greater than the threshold will cause an interrupt to 
be sent to the hart.

Interrupts with the same priority are processed in the order of their index in the interrupt 
table, with a higher index meaning a higher priority.

### Priority bits

The actual number of bits used to store the interrupt priority is device specific, but should be in the range [3-8].

If lower than 8 bits are implemented, the existing bits always store the most significant bits (MSB), 
with the least significant bits (LSB) ignored on write and reading 0.

<sup>The reason for removing the LSB instead of MSB is to make it easier to port software between RISC-V devices
with different priority bits. In this way, a program written for devices with 4-bit priority bits is likely to 
be able to run on devices with 3-bit priority bits. If the MSB 
is removed instead of the LSB, it might be possible to get a priority inversion,  
for example, if an application uses priority level 0x05 for IRQ0 and level 0x03 for IRQ1, IRQ0 should have higher 
priority. But when MSB bit 2 is removed, IRQ0 will become level 0x01 and have a lower priority than IRQ1.</sup>

### System interrupts

System interrupts are generated by system peripherals, like `sysclock`, `rtclock`.

### Interrupt table

The interrupt table is an array of pointers to interrupt handlers, implemented as C/C++ functions.

Each hart has its own table, with handlers for the interrupts it is processing.

The address of the array must be written by each hart to its `hcb.irqtab` register before enabling interrupts, usually during startup.

The first 8 entries are reserved for system interrupts:

* sysclock_tick
* rtclock_tick
* rtclock_wakeup
* context_switch

TODO: define the order, which gives the priorities.

### Interrupt control registers

Each interrupt has a 32-bits register with fields used to configurea and control the interrupt.

TBD












