# Exceptions and Interrupts

Exceptions are unusual conditions that occur at run time, associated with an 
instruction in the current RISC-V hart.

Interrupts are events that occur asynchronously outside any of the RISC-V harts.

## Exceptions

Exceptions trigger **a synchronous transfer of control** to an exception handler 
within the current hart.

Exceptions cannot be disabled, and handlers to process them should always be installed.

Some exceptions are **resumable**, i.e. execution can continue to the next 
instruction (for example the illegal instruction handler can implement a custom 
instruction and resume).

Exceptions, in decreasing priority order:

* Instruction address misaligned 
* Instruction access fault
* Illegal instruction
* Breakpoint
* Load address misaligned
* Load access fault
* Store/AMO address misaligned 
* Store/AMO access fault 
* Environment call from U-mode
* Environment call from M-mode
* Instruction page fault
* Load page fault
* Store/AMO page fault

TODO: rework for microcontrollers

TODO: NMI? routed only to hart 0?

### Exceptions vector table

The exceptions vector table is an array of addresses (xlen size elements) pointing to 
interrupt handlers (C/C++ functions).

The address of the exceptions vector table is kept by each hart in (`hcb.excvta`); 
it is automatically initialised at startup with 
the address provided in the hart startup block and can be later writen by software.

## Interrupts

Interrupts are generaly **triggered by peripherals** to notify the application of a 
given condition or event. 

Interrupts trigger the transfer of control to an interrupt handler associated with 
a hart.

A hart can have up to **1024** interrupts, including the system interrupts.

### Interrupt priorities

Interrupts have **programable priorities**, defined as small unsigned numbers, 
usually bytes.
The **priority value 0** is reserved to mean 
_'never interrupt'_ or _'disabled'_, and interrupt priorities increase with 
an increasing integer value.

Interrupts with the same priority are processed in the order of their index 
in the interrupt 
table, with a higher index meaning a higher priority.

For multi-hart devices, the interrupt wiring to harts is implementation specific; 
each interrupt 
may be wired to one or several harts; it is the responsibility 
of each hart to enable the interrupts it desires to process. For redundant systems, 
it is also
possible for multiple harts to process the same interrupt.

### Interrupt priority threshold

Each hart has an associated priority threshold, held in a hart-specific register. 

Only interrupts that have a priority strictly greater than the threshold will 
cause an interrupt to 
be sent to the hart.

### Priority bits

The actual number of bits used to store the interrupt priority is implementation 
specific, but must 
be at least 3 (i.e. at least 8 priority levels).

> <sup>Extra care must be considered when moving code to implmentations with fewer 
  priority levels, since truncation could lead to priority inversions.
  For example, when moving a program from devices 
  with 4-bit priority bits to devices with 3-bit priorities, if the application 
  uses priority 9 for IRQ0 and priority 3 
  for IRQ1, IRQ0 is expected to have a higher 
  priority. But if the MSB bit is removed, IRQ0 will have priority 1 and be 
  lower than IRQ1.</sup>
  
> <sup>It is 
  recommended that software handling priorities know about the numbr of bits 
  and use asserts to validate the priority values.</sup>

### Interrupt preemption and nesting

If an hart is executing an interrupt handler and a higher priority interrupt 
occurs, the current interrupt handler is temporarily suspended and the higher 
priority interrupt handler is executed to completion, than the first 
interrupt handler is resumed.

Each new interrupt creates a new context on the main stack, and removes it 
when the handler returns.

There is no limit for interrupt nesting, assuming the main stack is large enough.

### System interrupts

System interrupts are generated by system peripherals, like `sysclock`, `rtclock`.

TBD

### Interrupts vector table

The interrupts table is an **array of pointers** to interrupt handlers, 
implemented as **C/C++ functions**. The number of interrupts per hart is 
implementation specific but cannot exceed 1024 elements.

Each hart has its own table, with handlers for the interrupts it can process.

The address of the array must be programatically written by each hart to 
its `hcb.intvta` register before enabling interrupts, usually during startup.

The first 8 entries are reserved for system interrupts:

* `context_switch` (must have the lowest priority)
* `rtclock_cmp`
* `sysclock_cmp`

### Context stack

When exceptions and interrupts are taken, they push a context on the main stack. The stack pointer must be xlen aligned. For RV32 harts with the D extension, an additional alignment to 8 must be performed by adding a stack padding.

> <sup>ARM has a status bit that aligns the stack to 8 even if double precision is not used; depending on how caches are organised, it may lead to faster context switches it might be better to do the same.</sup>

For the current RISC-V Linux ABI, the stack context is, from hight to low addresses

- <- original SP 
- optional padding
- fcsr (\*) <- for double, it must be aligned to 8
- ft11 (\*)
- ft10 (\*)
- ft9 (\*)
- ft8 (\*)
- fa7 (\*)
- fa6 (\*)
- fa5 (\*)
- fa4 (\*)
- fa3 (\*)
- fa2 (\*)
- fa1 (\*)
- fa0 (\*)
- ft7 (\*)
- ft6 (\*)
- ft5 (\*)
- ft4 (\*)
- ft3 (\*)
- ft2 (\*)
- ft1 (\*)
- ft0 (\*)
- status (?)
- pc (the return address)
- t6
- t5
- t4
- t3
- a7
- a6
- a5
- a4
- a3
- a2
- a1
- a0
- t2
- t1
- t0
- ra <- new SP

The floating point registers are not saved by devices that do not implement the 
F or D extentions and do not have the `ctrl.fpena` bit set.

After saving the context stack:

- the `ra` register is adjust to a special pattern 
that is illegal as a return address, to instruct the core to return from the 
interrupt/exception
- the status register that identifies the curent mode is set to thread-mode.

The special pattern is an 'all-1' for the given xlen.









