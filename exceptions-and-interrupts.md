# Exceptions and Interrupts

Exceptions are unusual conditions occuring at run time, associated with an instruction in the current RISC-V hart.

Interrupts are events that occur asynchronously outside any of the RISC-V harts.

## Exceptions

Exceptions trigger **a synchronous transfer of contro**l to an exception handler within the current hart.

Exceptions cannot be disabled, and handlers to process them should always be installed.

Some exceptions are **resumable**, i.e. execution can continue to the next instruction (for example the illegal instruction handler can implement a custom instruction and resume).

Exceptions, in decreasing priority order:

* Instruction address misaligned 
* Instruction access fault
* Illegal instruction
* Breakpoint
* Load address misaligned
* Load access fault
* Store/AMO address misaligned 
* Store/AMO access fault 
* Environment call from U-mode
* Environment call from M-mode
* Instruction page fault
* Load page fault
* Store/AMO page fault

TODO: rework for microcontrollers

TODO: NMI? routed only to hart 0?

### Exceptions vector table

The exceptions vector table is an array of addresses (xlen size elements) pointing to 
interrupt handlers (C/C++ functions).

Its address is kept in (`hcb.excvta`); it is automatically initialised at startup with 
the address provided in the hart startup block and can be be later writen by software.

## Interrupts

Interrupts are generaly **triggered by peripherals** to notify the application of a 
given condition or event. 

Interrupts trigger the transfer of control to an interrupt handler associated with a hart.

A hart can have up to **1024** interrupts, including the system interrupts.

### Interrupt priorities

Interrupts have **programable priorities**, defined as small unsigned numbers, 
usually bytes.
The **priority value 0** is reserved to mean 
_'never interrupt'_ or _'disabled'_, and interrupt priorities increase with 
an increasing integer value.

Interrupts with the same priority are processed in the order of their index 
in the interrupt 
table, with a higher index meaning a higher priority.

For multi-hart devices, the interrupt wiring to harts is implementation specific; 
each interrupt 
may be wired to one or several harts; it is the responsibility 
of each hart to enable the interrupts it desires to process. For redundant systems, 
it is also
possible for multiple harts to process the same interrupt.

### Interrupt priority threshold

Each hart has an associated priority threshold, held in a hart-specific register. 

Only interrupts that have a priority strictly greater than the threshold will 
cause an interrupt to 
be sent to the hart.

### Priority bits

The actual number of bits used to store the interrupt priority is implementation 
specific, but must 
be at least 3 (i.e. at least 8 priority levels).

> <sup>Extra care must be taken when moving code to implmentations with fewer 
  priority levels, since truncation could lead to priority inversions; it is 
  recommended that software handling priorities know about the numbr of bits 
  and use asserts to validate the priority values.</sup>
  
> <sup>For example, when moving a program from devices 
  with 4-bit priority bits to devices with 3-bit priorities, if the application 
  uses priority 0x05 for IRQ0 and priority 0x03 
  for IRQ1, IRQ0 is expected to have a higher 
  priority. But if MSB bit 2 is removed, IRQ0 will become level 0x01 and have a 
  lower priority than IRQ1.</sup>

### System interrupts

System interrupts are generated by system peripherals, like `sysclock`, `rtclock`.

TBD

### Interrupts vector table

The interrupts table is an **array of pointers** to interrupt handlers, implemented as **C/C++ functions**. The number of interrupts per hart is implementation specific but cannot exceed 1024 elements.

Each hart has its own table, with handlers for the interrupts it can process.

The address of the array must be programatically written by each hart to its `hcb.intvta` register before enabling interrupts, usually during startup.

The first 8 entries are reserved for system interrupts:

* `context_switch` (must have the lowest priority)
* `rtclock_cmp`
* `sysclock_cmp`





