# Exceptions and Interrupts

Exceptions are generally unusual conditions occuring at run time, associated with an instruction in the current RISC-V hart.

Interrupts are external events that occur asynchronously outside any of the RISC-V harts.

## Exceptions

Exceptions trigger a synchronous transfer of control to an exception handler within the current hart.

Exceptions cannot be disabled, and handlers to process them should always be installed.

Some exceptions are resumable, i.e. execution can continue to the next instruction (for example the illegal instruction handler can implement a custom instruction and resume).

Exceptions, in decreasing priority order:

* Instruction address misaligned 
* Instruction access fault
* Illegal instruction
* Breakpoint
* Load address misaligned
* Load access fault
* Store/AMO address misaligned 
* Store/AMO access fault 
* Environment call from U-mode
* Environment call from M-mode
* Instruction page fault
* Load page fault
* Store/AMO page fault

TODO: rework for microcontrollers
TODO: NMI? routed only to hart 0?

## Interrupts

Interrupts are generaly triggered by peripherals to notify the application of a given condition or event. 

Interrupts trigger the transfer of control to an interrupt handler associated with a hart.

A hart can have up to 1024 interrupts, including the system interrupts.

### Interrupt priorities

Interrupts have programable priorities, defined as small unsigned numbers, usually bytes.
The priority value 0 is reserved to mean 
'never interrupt' or 'disabled', and interrupt priority increases with increasing integer value.

Interrupts with the same priority are processed in the order of their index in the interrupt 
table, with a higher index meaning a higher priority.

For multi-hart devices, the interrupt wiring to harts is device dependent, each interrupts 
may be wired to one or several harts; it is the responsibility 
of each hart to enable the interrupts it desires to process. For redundant systems, it is also
possible for multiple harts to process the same interrupt.

### Interrupt priority threshold

Each hart has an associated priority threshold, held in a hart-specific memory mapped register. The 
threashold register should always be able to hold the value of zero, in which case no interrupts are 
masked. The threshold register should be able to hold the 'all-1' value, in wich case all interrupts 
are masked (functionally equivalent to disabling interrupts).

Only interrupts that have a priority strictly greater than the threshold will cause an interrupt to 
be sent to the hart.


### Priority bits

The actual number of bits used to store the interrupt priority is implementation specific, but should be in the range [3-8].

If lower than 8 bits are implemented, the existing bits should always store the most significant bits (MSB), 
with the least significant bits (LSB) ignored on write and reading 0.

> <sup>The reason for removing the LSB instead of MSB is to make it easier to port software between RISC-V devices
with different priority bits schemes. In this way, a program written for devices with 4-bit priority bits is likely to 
be able to run on devices with 3-bit priority bits. If the MSB 
is removed instead of the LSB, it might be possible to get a priority inversion,  
for example, if an application uses priority level 0x05 for IRQ0 and level 0x03 for IRQ1, IRQ0 should have higher 
priority. But when MSB bit 2 is removed, IRQ0 will become level 0x01 and have a lower priority than IRQ1.</sup>

### System interrupts

System interrupts are generated by system peripherals, like `sysclock`, `rtclock`.

TBD

### Interrupts table

The interrupt table is an array of pointers to interrupt handlers, implemented as C/C++ functions. The number of interrupts per hart is implementation specific but cannot exceed 1024 elements

Each hart has its own table, with handlers for the interrupts it is processing.

The address of the array must be written by each hart to its `hcb.irqtab` register before enabling interrupts, usually during startup.

The first 8 entries are reserved for system interrupts:

* `context_switch` (must have the lowest priority)
* `rtclock_wakeup`
* `rtclock_tick`
* `sysclock_tick`

### Interrupt control registers

Each interrupt has the following status attributes:

* interrupts can either be disabled (default) or enabled 
* interrupts can either be pending (a request is waiting to be served) or not
pending
* interrupts can either be in an active (being served) or inactive state
* interrupt priority

To store and control these attributes, each interrupt has a 32-bits register with the following fields:


| Bits | Name | Type | Description |
|:-----|:-----|:-----|-------------|
| [7-0] | `prio` | rw | If non zero, the interrupt priority. |
| [15-8] | `status`| r | Status bits |
| [23-16] | `set` | 1s | Set bits. |
| [31-24] | `clear` | 1c | Clear bits. |

The `status` bits:

| Bits | Name | Type | Description |
|:-----|:-----|:-----|-------------|
| [0] | `enbled` | r | Enabled status bit; 1 if the interupt is enabled. |
| [1] | `pending` | r | Pending status bit; 1 if the interupt is pending. |
| [2] | `active` | r | Active status bit; 1 if the interupt is active. | 
| [7-3] ||| Reserved |

The `set` bits:

| Bits | Name | Type | Description |
|:-----|:-----|:-----|-------------|
| [0] | `enabled` | 1s | When 1 is written, the `enabled` bit is set. |
| [1] | `pending` | 1s | When 1 is written, the `pending` bit is set. |
| [7-2] ||| Reserved |

The `clear` bits:

| Bits | Name | Type | Description |
|:-----|:-----|:-----|-------------|
| [0] | `enabled` | 1s | When 1 is written, the `enabled` bit is cleared. |
| [1] | `pending` | 1s | When 1 is written, the `pending` bit is cleared. |
| [7-2] ||| Reserved |

### Usage

Individual interrupts are enabled by setting the `status.enabled` bit and writing a non-zero value to the `prio` field, and are disabled by clearing the `enabled` bit.

```c
hcb.interrupts[7].prio = 0xC0; // A byte write cycle.
hcb.interrupts[7].set = INTERRUPTS_SET_ENABLED; // A byte write cycle.

hcb.interrupts[7].clear = INTERRUPTS_CLEAR_ENABLED; // A byte write cycle.
```

Interrupts can be programatically set to pending by writing 1 in the `set_pend` field; the pending status can be cleared by writing 1 to the `clear_pend` field.

```c
hcb.interrupts[7].set = INTERRUPTS_SET_PENDING; // A byte write cycle.
hcb.interrupts[7].clear = INTERRUPTS_CLEAR_PENDING; // A byte write cycle.
```

To check the status bits:

```c
if (hcb.interrupts[7].status & INTERRUPTS_STATUS_PENDING) { // A byte read cycle.
  // ...
}
```


